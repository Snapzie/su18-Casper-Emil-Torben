\section{Design}

For at gøre et spil underholdende, skal det helst være muligt at tabe (og ligeså at vinde). Af denne årsag har vi lavet forskellige states, der stopper spillet og viser en menu, som der viser "You win" eller "You lost" alt efter omstændighederne. Spillet vindes ved, at alle fjender bliver skudt.
Vi gjorde et forsøg på at sørge for at skibet ville springe i luften når en fjende ramte skibet, dette lykkedes dog ikke. Derfor tabes spillet blot når en eller flere fjender går under et vist punkt. Mere præcist benyttes, at man kender til fjendernes position, idet de er Entities med en position, der kan tjekkes om hvorvidt nogen af dem er nået til bunden af skærmen. Ligeså er player en entity med samme egenskaber, foruden at dens bevægelse ikke er forudbestemt af nogen algoritme, men afhænger af hvilke inputs spilleren foretager sig (og dermed hvilke events, der udføres).
Designet af playeren og fjenderne er udleveret på forhånd, og de vises visuelt ved at benytte DIKUArcades class Image, som har metoder der formår at benytte de udleverede PNG-filer med sprites og rendere dem.
En anden state er, at spillet til et vilkårligt tidspunnkt kan pauses ved at trykke escape og kan fortsættes ved at trykke "continue". Dette har vist sig oplagt at implementere vha. en event, da vi allerede har en event-processor til at tjekke, hvilke keys, som bliver trykket, og i tilfælde af at den pågældende knap er "escape", da bliver der skiftet til en pause-state.
For at skabe blot en anelse mere spænding i spillet, er der blevet implementeret bevægelse samt formationer hos modstanderne. Formation er skabt ved at instantiere modstanderne de rigtige steder og så dernæst sørge for, at hvert lag bevæger sig uniformt for at opretholde formationen. I den bevægende formation ZigZagDown, foregår bevægelsen eksempelvist ved at rykke på fjendernes position som en sinusbølge, således at de får en flydende bølge-agtig bevægelse. Det er også med til at sørge for, at ingen af fjenderne overlapper, da de relative positioner mellem fjenderne i hvert lag ikke forandrer sig. Dermed er der ikke årsag til at tage hensyn til, hvordan drab af overlappende fjender ville fungere, da det ikke kan forekomme.
For at undgå, at denne bevægelse resulterer i, at fjenderne bevæger sig udenfor skærmen, har vi siden forhenværende aflevering fjernet nogen fjender således, at udstrækningen af bevægelsen ikke er større end hvad skærmen tillader.
